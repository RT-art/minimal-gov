
aws organization

●●オーガニゼーション本体の作成●●
→ここでは土台を作るのみ
scpの作成や、アカウント作成できない

よくつかう表現
■feature_set = "ALL"
とりあえず書いとけみたいなやつ

■  enabled_policy_types = [
    "SERVICE_CONTROL_POLICY",
    # 必要なら "TAG_POLICY", "BACKUP_POLICY"
  ]
明示的に、scpを使うと定義する

■  aws_service_access_principals
 = distinct(concat(
    [
      "guardduty.amazonaws.com",
      "config.amazonaws.com",
      "cloudtrail.amazonaws.com",
      "securityhub.amazonaws.com"
    ],
    var.delegate_admin_for
  ))

将来、securityアカウントに管理を委任するため、書かないといけない。
サービスアクセス許可で、特定サービスの委任準備ができる。

distinctは重複削除
distinct(["a", "b", "a"]) → ["a", "b"]

concatは複数のリストをひとつにする
→固定サービスの４つと、tfvarで指定したサービスを組み合わせてリストにしている

→
ローカルで
aws_service_access_principals = setunion(
    [
      "guardduty.amazonaws.com",
      "config.amazonaws.com",
      "cloudtrail.amazonaws.com",
      "securityhub.amazonaws.com"
    ],
    var.delegate_admin_for
  )
  と設定。
 setunionは、set型を重複削除し、リストを合体させる
 set型により、for_each使える
 aws_service_access_principals = local.aws_service_access_principals


●●OU●●
同じく箱を作るぐらい
resource "aws_organizations_organizational_unit" "security" {
  name      = "Security"
  parent_id = local.root_id
  tags      = local.tags
}

resource "aws_organizations_organizational_unit" "workloads" {
  name      = "Workloads"
  parent_id = local.root_id
  tags      = local.tags
}
...とひたすらリソース定義

OUは、明確にベストプラクティスがあり、基本変更しないため、moduleでハードコーディング

# Root
# ├─ Security
# ├─ Workloads
# │   ├─ Prod
# │   └─ Dev
# ├─ Sandbox

●●アカウント●●
localでreally_close = var.close_account_on_destroy && var.close_account_confirmation == "I_UNDERSTAND"

&&は　AND(かつ)
→フラグが true で確認文字列が "I_UNDERSTAND" と一致しているときだけ
resource "aws_organizations_account" "security" {
  name      = var.security_account_name #アカウント名
  email     = var.security_account_email # 他アカウントと重複しないメールアドレス
  role_name = var.org_admin_role_name  #新規追加アカウントに自動的に作られるIAMロール
  parent_id = aws_organizations_organizational_unit.security.id #このアカウントをぶら下げる OU の ID を指定
  tags      = merge(local.tags, { AccountType = "Security" })
}
    lifecycle {
    ignore_changes = var.lock_account_name ? [name] : []
  }

ライフサイクルは、リソースブロックでのみ定義
代表的なもの：
ignore_changes → 指定属性の差分を無視
prevent_destroy → そのリソースを destroy で消せないようにする
create_before_destroy → 置換が必要なとき、先に新しいものを作ってから古いものを消す

ignore_changes = ...
指定した属性が変わっていても Terraform plan では差分として表示しないし、apply でも変更を当てない。

var.lock_account_name ? [name] : []
var.lock_account_nameがtrueかfalseで、どうするか決める
trueなら、name
falseなら[]
→→ignore_changesは属性が変わっていたら、表示をしないため、trueにしたら、nameを表示しないってことになる
terraformでアカウント名を変更すると、一度削除してもう一度アカウントを作ろうとする。それを阻止するため。
かならず、terraformでは名前を変更しない。

  close_on_deletion = local.really_close

  # close_account_on_destroyがfalseの時、アカウントが組織を脱退する
  # close_account_on_destroyがtrueの時、errorメッセージが表示され、I_UNDERSTANDを入力すると閉鎖
  precondition {
    condition     = !(var.close_account_on_destroy) || local.really_close
    error_message = "アカウントを閉鎖するには close_account_confirmation に 'I_UNDERSTAND' を指定してください。"
  }
  terraformでアカウントを削除しようとすると、デフォルトは組織を脱退するのみ。
  完全に閉鎖したいときに使う
  
  precondition { ... }は、条件が満たされなければapplyをしっぱいさせる関数
  condition = !(var.close_account_on_destroy) || local.really_close
   !(var.close_account_on_destroy) で、falseのときtrueにする(!の影響で)
   
 
resource "aws_organizations_account" "members" {
  for_each  = var.member_accounts 
  name      = each.key
  email     = each.value.email
  role_name = var.org_admin_role_name
  parent_id = lookup({
    "Security"        = aws_organizations_organizational_unit.security.id,
    "Workloads"       = aws_organizations_organizational_unit.workloads.id,
    "Workloads/Prod"  = aws_organizations_organizational_unit.prod.id,
    "Workloads/Dev"   = aws_organizations_organizational_unit.dev.id,
    "Sandbox"         = aws_organizations_organizational_unit.sandbox.id,
    "Suspended"       = aws_organizations_organizational_unit.suspended.id
  }, each.value.ou, aws_organizations_organizational_unit.sandbox.id)

  tags = merge(local.tags, { AccountType = "Member" })
}

tfvarのmapを受け取り、そこに書いてある内容を見て作成
member_accounts = {
  prod = { email = "prod@example.com", ou = "Workloads/Prod" }
  dev  = { email = "dev@example.com",  ou = "Workloads/Dev" }
}
each.keyは、prodとかdev
each.value.emailは、バリュー（emailかouのどっちか）の、emailのほう
parent_idのところは、ouの値から、OUidを紐づけしている


●●セキュリティアカウントに委任●●
resource "aws_organizations_delegated_administrator" "security_delegate" {
  for_each = local.aws_service_access_principals

  account_id        = aws_organizations_account.security.id
  service_principal = each.value

セキュリティアカウントが作られたあと　オーガニゼーション本体がつくられたあと
  depends_on = [aws_organizations_account.security, aws_organizations_organization.this]
}



